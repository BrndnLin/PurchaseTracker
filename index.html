<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Theme color now uses the midnight blue primary color for mobile browser UI -->
    <meta name="theme-color" content="#0ea5e9">
    <title>Purchase Tracker</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific meta tags for better PWA experience -->
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <!-- Favicon fix -->
    <link rel="icon" type="image/png" href="icon-192.png">
    
    <style>
        /* ============================================
         * CSS CUSTOM PROPERTIES (CSS Variables)
         * ============================================
         * CSS Variables allow us to define reusable values that can be changed in one place.
         * Think of them like constants in programming - define once, use everywhere.
         * Variables are defined with -- prefix and used with var() function.
         */
        :root {
            /* MIDNIGHT BLUE THEME COLORS
             * These colors create a dark, professional look with blue accents
             * Each color serves a specific purpose in the UI design
             */
            --primary-color: #0ea5e9;    /* Main brand color - bright sky blue for buttons, headings */
            --primary-dark: #0284c7;     /* Darker version for hover states and pressed buttons */
            --primary-light: #38bdf8;    /* Lighter version for subtle highlights */
            --accent-color: #06d6a0;     /* Complementary green for success states and positive actions */
            
            /* BACKGROUND COLORS
             * Dark theme uses multiple shades of dark blue/gray for depth
             */
            --background: #0c1420;       /* Main page background - very dark blue */
            --surface: #1e293b;          /* Card/container backgrounds - lighter than main background */
            
            /* TEXT COLORS
             * Light colors on dark background for good contrast and readability
             */
            --text-primary: #f8fafc;     /* Main text color - almost white for high contrast */
            --text-secondary: #94a3b8;   /* Secondary text - gray for less important info */
            
            /* UI ELEMENT COLORS */
            --border-color: #475569;     /* Borders between elements - medium gray */
            --danger-color: #ef4444;     /* Red for errors and warnings */
            --warning-color: #f59e0b;    /* Orange/yellow for caution states */
            
            /* SPACING SYSTEM
             * Consistent spacing creates visual harmony and makes the design feel organized
             * Using multiples of 4px is a common design system practice
             */
            --spacing-xs: 4px;   /* Extra small - for tight spacing */
            --spacing-sm: 8px;   /* Small - for compact layouts */
            --spacing-md: 16px;  /* Medium - most common spacing */
            --spacing-lg: 24px;  /* Large - for section separation */
            --spacing-xl: 32px;  /* Extra large - for major sections */
            
            /* BORDER RADIUS SYSTEM
             * Consistent rounded corners create a modern, friendly feel
             */
            --radius-sm: 6px;    /* Small radius for buttons and inputs */
            --radius-md: 12px;   /* Medium radius for cards */
            --radius-lg: 16px;   /* Large radius for major containers */
            
            /* MOBILE DEVICE SUPPORT
             * Safe area handles the "notch" on newer iPhones and curved screens
             */
            --safe-area-bottom: env(safe-area-inset-bottom);
        }

        /* ============================================
         * RESET AND BASE STYLES
         * ============================================
         * CSS Reset removes browser default styling to ensure consistency
         * across different browsers (Chrome, Firefox, Safari, etc.)
         */
        * {
            margin: 0;           /* Remove default margins */
            padding: 0;          /* Remove default padding */
            box-sizing: border-box;  /* Include padding/border in element width calculations */
        }

        /* BODY STYLING
         * Sets up the basic appearance and behavior of the entire page
         */
        body {
            /* Font stack: tries -apple-system first (macOS), then BlinkMacSystemFont (Chrome on macOS),
             * then falls back to common system fonts for best performance and native look */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background);  /* Use our dark blue background */
            color: var(--text-primary);           /* Use light text color */
            line-height: 1.6;                     /* Improve text readability with more line spacing */
            -webkit-font-smoothing: antialiased;  /* Make fonts look smoother on macOS/iOS */
            padding-bottom: var(--safe-area-bottom);  /* Account for iPhone home indicator */
        }

        /* ============================================
         * LAYOUT CONTAINERS
         * ============================================
         */
        
        /* MAIN CONTAINER
         * Centers content and provides consistent spacing on all screen sizes
         */
        .container {
            max-width: 600px;                    /* Limit width on large screens for better readability */
            margin: 0 auto;                      /* Center horizontally */
            padding: var(--spacing-md);          /* Add padding on all sides */
            padding-bottom: var(--spacing-md);   /* Bottom padding (no longer need space for bottom nav) */
        }

        /* HEADER STYLING
         * Sticky header stays at top when scrolling for easy access to app title
         */
        .header {
            background: var(--surface);          /* Use surface color for contrast with main background */
            padding: var(--spacing-lg) var(--spacing-md);  /* More vertical padding for visual importance */
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);  /* Subtle shadow to separate from content */
            position: static;                     /* Normal positioning */
            top: 0;                              /* Stick to very top of viewport; not necessary if static */
            z-index: 100;                        /* Ensure header appears above other content */
        }

        .header h1 {
            font-size: 24px;                     /* Large, readable title */
            color: var(--primary-color);         /* Use brand color for the title */
            text-align: center;                  /* Center the title */
        }

        /* ============================================
         * STATISTICS CARDS
         * ============================================
         * Grid layout automatically arranges cards side by side on larger screens,
         * stacks them vertically on smaller screens
         */
        .stats-container {
            display: grid;                        /* Use CSS Grid for flexible layout */
            grid-template-columns: 1fr 1fr;      /* Two equal-width columns */
            gap: var(--spacing-md);              /* Space between cards */
            margin-bottom: var(--spacing-lg);    /* Space below the stats section */
        }

        .stat-card {
            background: var(--surface);          /* Card background color */
            padding: var(--spacing-md);          /* Inner spacing */
            border-radius: var(--radius-md);     /* Rounded corners */
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);  /* Subtle shadow for depth */
            text-align: center;                  /* Center all content in the card */
        }

        .stat-label {
            font-size: 12px;                     /* Small text for the label */
            color: var(--text-secondary);        /* Dimmer color for less emphasis */
            text-transform: uppercase;           /* ALL CAPS for style */
            letter-spacing: 0.5px;              /* Slight spacing between letters */
        }

        .stat-value {
            font-size: 24px;                     /* Large, prominent number */
            font-weight: 600;                    /* Semi-bold for emphasis */
            color: var(--primary-color);         /* Brand color to draw attention */
            margin-top: var(--spacing-xs);       /* Small space above the number */
        }

        /* ============================================
         * PURCHASE FORM STYLING
         * ============================================
         */
        .purchase-form {
            background: var(--surface);          /* Card-like appearance */
            padding: var(--spacing-lg);          /* Generous inner spacing */
            border-radius: var(--radius-lg);     /* More rounded corners for friendliness */
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);  /* Depth shadow */
            margin-bottom: var(--spacing-lg);    /* Space below form */
        }

        .form-group {
            margin-bottom: var(--spacing-md);    /* Space between form fields */
        }

        /* FORM ROW LAYOUT
         * NEW: Allows description and amount to sit side by side for space optimization
         * Uses flexbox for responsive layout that stacks on very small screens
         */
        .form-row {
            display: flex;                        /* Horizontal layout */
            gap: var(--spacing-md);              /* Space between description and amount fields */
        }

        /* FORM LABELS
         * Clear, readable labels help users understand what to enter
         */
        label {
            display: block;                       /* Labels take full width, stack above inputs */
            font-size: 14px;                     /* Readable but not too large */
            font-weight: 500;                    /* Medium weight for clarity */
            color: var(--text-secondary);        /* Slightly dimmer than main text */
            margin-bottom: var(--spacing-xs);    /* Small gap between label and input */
        }

        /* FORM INPUTS AND SELECTS
         * Consistent styling for all input types creates a cohesive experience
         */
        input, select {
            width: 100%;                          /* Full width of container */
            padding: var(--spacing-md);          /* Comfortable padding for touch targets */
            border: 1px solid var(--border-color);  /* Subtle border */
            border-radius: var(--radius-sm);     /* Slightly rounded corners */
            font-size: 16px;                     /* Prevents zoom on iOS devices */
            background: var(--background);       /* Slightly different from surface for contrast */
            color: var(--text-primary);          /* Ensure text is readable */
            transition: all 0.2s;                /* Smooth animation for focus states */
        }

        /* AMOUNT INPUT OPTIMIZATION
         * NEW: Smaller width for amount field since it's typically just a few digits
         * flex-shrink: 0 prevents it from getting smaller than 120px
         */
        .amount-input {
            width: 120px;                         /* Fixed width for amount field */
            flex-shrink: 0;                       /* Don't shrink below this width */
        }

        /* FOCUS STATES
         * Visual feedback when user clicks/taps on form elements
         */
        input:focus, select:focus {
            outline: none;                        /* Remove default browser outline */
            border-color: var(--primary-color);  /* Highlight border with brand color */
            box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);  /* Subtle glow effect */
        }

        /* ============================================
         * CATEGORY BUTTON STYLING
         * ============================================
         * NEW SECTION: Replaces the dropdown select with interactive buttons
         * Provides better mobile experience and faster category selection
         */
        
        /* CATEGORY BUTTON GRID
         * 2-column grid layout that works well on mobile devices
         * Automatically adjusts to container width while maintaining consistent spacing
         */
        .category-grid {
            display: grid;                        /* Use CSS Grid for precise control */
            grid-template-columns: 1fr 1fr;      /* Two equal-width columns */
            gap: var(--spacing-sm);              /* Space between buttons */
        }

        /* INDIVIDUAL CATEGORY BUTTONS
         * Styled to look clickable and provide clear visual feedback
         * Large enough for comfortable touch interaction on mobile devices
         */
        .category-btn {
            padding: var(--spacing-md);          /* Comfortable padding for touch targets */
            border: 1px solid var(--border-color);  /* Subtle border to define button area */
            border-radius: var(--radius-sm);     /* Rounded corners to match other form elements */
            background: transparent;             /* Transparent background in unselected state */
            color: var(--text-secondary);        /* Muted text color for unselected buttons */
            font-size: 14px;                     /* Readable text size */
            cursor: pointer;                      /* Hand cursor indicates interactive element */
            transition: all 0.2s;                /* Smooth animation for hover and selection */
            text-align: center;                  /* Center the category text */
            font-weight: 500;                    /* Medium font weight for better readability */
            /* Remove default button styling that browsers add */
            font-family: inherit;                /* Use same font as rest of page */
            -webkit-appearance: none;            /* Remove iOS default button styling */
            appearance: none;                    /* Standard property for broader compatibility */
        }

        /* CATEGORY BUTTON HOVER STATE
         * Provides immediate visual feedback when user hovers over a button
         * Helps users understand which button they're about to click
         */
        .category-btn:hover {
            border-color: var(--primary-color);  /* Brand color border on hover */
            color: var(--text-primary);          /* Brighter text on hover */
            background: rgba(14, 165, 233, 0.05); /* Very subtle background tint */
        }

        /* CATEGORY BUTTON SELECTED STATE
         * Clear visual indication of which category is currently selected
         * Uses brand colors to make selection obvious
         */
        .category-btn.selected {
            background: var(--primary-color);    /* Brand color background when selected */
            border-color: var(--primary-color);  /* Matching border color */
            color: white;                         /* White text for contrast against blue background */
        }

        /* CATEGORY BUTTON ACTIVE/PRESSED STATE
         * Provides tactile feedback when button is being pressed
         * Small scale effect mimics physical button press
         */
        .category-btn:active {
            transform: scale(0.98);              /* Slightly shrink when pressed */
        }

        /* ============================================
         * BUTTON STYLING
         * ============================================
         */
        .btn {
            display: block;                       /* Full-width buttons */
            width: 100%;                          /* Take full container width */
            padding: var(--spacing-md);          /* Comfortable padding for touch */
            border: none;                         /* Remove default button border */
            border-radius: var(--radius-sm);     /* Rounded corners */
            font-size: 16px;                     /* Readable text */
            font-weight: 600;                    /* Semi-bold for emphasis */
            cursor: pointer;                      /* Hand cursor indicates clickable */
            transition: all 0.2s;                /* Smooth animations */
        }

        /* PRIMARY BUTTON
         * Main action button (like "Add Purchase") gets the brand color
         */
        .btn-primary {
            background: var(--primary-color);    /* Brand color background */
            color: white;                         /* White text for contrast */
        }

        /* BUTTON ACTIVE STATE
         * Visual feedback when button is pressed/tapped
         */
        .btn-primary:active {
            background: var(--primary-dark);     /* Darker shade when pressed */
            transform: scale(0.98);              /* Slightly shrink for press effect */
        }

        .btn-secondary {
            background: var(--border-color);     /* Neutral background */
            color: var(--text-primary);          /* Normal text color */
        }

        /* ============================================
         * RECENT PURCHASES SECTION
         * ============================================
         */
        .recent-purchases {
            background: var(--surface);          /* Card background */
            border-radius: var(--radius-lg);     /* Rounded corners */
            padding: var(--spacing-lg);          /* Inner spacing */
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);  /* Depth shadow */
        }

        /* SECTION HEADER
         * Contains the title and sync controls in a horizontal layout
         */
        .section-header {
            display: flex;                        /* Horizontal layout */
            justify-content: space-between;      /* Push title left, controls right */
            align-items: center;                  /* Vertically center both elements */
            margin-bottom: var(--spacing-md);    /* Space below header */
        }

        .section-title {
            font-size: 18px;                     /* Prominent section heading */
            font-weight: 600;                    /* Semi-bold for emphasis */
        }

        /* INDIVIDUAL PURCHASE ITEMS
         * Each purchase is displayed as a row with description on left, amount on right
         */
        .purchase-item {
            padding: var(--spacing-md);          /* Comfortable padding */
            border-bottom: 1px solid var(--border-color);  /* Separator line */
            display: flex;                        /* Horizontal layout */
            justify-content: space-between;      /* Description left, amount right */
            align-items: center;                  /* Vertically center content */
        }

        /* Remove border from last item to avoid double-border with container */
        .purchase-item:last-child {
            border-bottom: none;
        }

        .purchase-info {
            flex: 1;                              /* Take up remaining space */
        }

        .purchase-description {
            font-weight: 500;                    /* Medium weight for the main text */
            margin-bottom: var(--spacing-xs);    /* Small gap before meta info */
        }

        /* META INFORMATION
         * Category and timestamp in smaller, dimmer text
         */
        .purchase-meta {
            font-size: 12px;                     /* Smaller text */
            color: var(--text-secondary);        /* Dimmer color */
        }

        .purchase-amount {
            font-size: 18px;                     /* Prominent amount display */
            font-weight: 600;                    /* Bold for emphasis */
            color: var(--primary-color);         /* Brand color to highlight money */
        }

        /* ============================================
         * SYNC CONTROLS AND STATUS
         * ============================================
         */
        
        /* SYNC CONTROLS CONTAINER
         * Groups the sync button and status indicator together
         */
        .sync-controls {
            display: flex;                        /* Horizontal layout */
            align-items: center;                  /* Vertically center */
            gap: var(--spacing-sm);              /* Small gap between button and status */
        }

        /* SMALL SYNC BUTTON
         * Compact button that sits next to the sync status
         */
        .sync-btn-small {
            width: 40px;                          /* Square button */
            height: 40px;                         /* Square button */
            padding: 2px;                         /* Minimal padding */
            border: 1px solid var(--border-color);  /* Subtle border */
            border-radius: var(--radius-sm);     /* Rounded corners */
            background: var(--surface);          /* Same as container background */
            color: var(--text-secondary);        /* Muted color */
            cursor: pointer;                      /* Hand cursor */
            transition: all 0.2s;                /* Smooth hover effects */
            display: flex;                        /* Center the icon */
            align-items: center;                  /* Center vertically */
            justify-content: center;             /* Center horizontally */
        }

        /* REFRESH ICON STYLING
         * Style the refresh icon image inside the sync button
         */
        .refresh-icon-img {
            width: 26px;                          /* Icon size */
            height: 26px;                         /* Icon size */
            opacity: 0.6;                         /* Slightly transparent */
            transition: opacity 0.2s;            /* Smooth opacity change */
        }

        /* HOVER EFFECTS
         * Visual feedback when user hovers over sync button
         */
        .sync-btn-small:hover .refresh-icon-img {
            opacity: 1;                           /* Full opacity on hover */
        }

        .sync-btn-small:hover {
            background: var(--background);       /* Slight background change */
            color: var(--primary-color);         /* Brand color */
        }

        /* ACTIVE/PRESSED STATE */
        .sync-btn-small:active {
            transform: scale(0.95);              /* Slightly shrink when pressed */
        }

        /* SYNC STATUS INDICATOR
         * Shows current sync state with colored dot and text
         */
        .sync-status {
            display: flex;                        /* Horizontal layout */
            align-items: center;                  /* Vertically center */
            gap: var(--spacing-sm);              /* Gap between dot and text */
            padding: var(--spacing-sm) var(--spacing-md);  /* Comfortable padding */
            background: var(--background);       /* Subtle background difference */
            border-radius: var(--radius-sm);     /* Rounded corners */
            font-size: 14px;                     /* Readable text size */
        }

        #syncText {
            text-align: left;                   /* Center the text */
            line-height: 1.2;                     /* Tighter line spacing */
        }

        /* SYNC STATUS DOT
         * Colored indicator that shows sync state visually
         */
        .sync-indicator {
            width: 8px;                           /* Small dot */
            height: 8px;                          /* Small dot */
            border-radius: 50%;                   /* Perfect circle */
            background: var(--accent-color);     /* Green for synced state */
        }

        /* DIFFERENT STATES FOR SYNC INDICATOR */
        .sync-indicator.pending {
            background: var(--warning-color);    /* Orange/yellow for pending */
        }

        .sync-indicator.error {
            background: var(--danger-color);     /* Red for errors */
        }

        /* ============================================
         * ANIMATIONS AND LOADING STATES
         * ============================================
         */
        
        /* SPINNING ANIMATION
         * Used for loading indicators to show something is happening
         */
        @keyframes spin {
            to { transform: rotate(360deg); }    /* Rotate 360 degrees */
        }

        /* LOADING SPINNER
         * Small spinning circle to indicate processing
         */
        .loading {
            display: inline-block;               /* Inline with text */
            width: 16px;                         /* Small size */
            height: 16px;                        /* Small size */
            border: 2px solid var(--border-color);  /* Light gray border */
            border-top-color: var(--primary-color); /* Brand color on top */
            border-radius: 50%;                  /* Perfect circle */
            animation: spin 0.8s linear infinite;   /* Continuous spinning */
        }

        /* ============================================
         * EMPTY STATE AND MESSAGES
         * ============================================
         */
        
        /* EMPTY STATE
         * Shown when no purchases exist yet
         */
        .empty-state {
            text-align: center;                  /* Center the message */
            padding: var(--spacing-xl);         /* Generous padding */
            color: var(--text-secondary);       /* Dimmer color for less emphasis */
        }

        /* ERROR MESSAGES
         * Red background for error notifications
         */
        .error-message {
            background: var(--danger-color);    /* Red background */
            color: white;                        /* White text for contrast */
            padding: var(--spacing-md);         /* Comfortable padding */
            border-radius: var(--radius-sm);    /* Rounded corners */
            margin-bottom: var(--spacing-md);   /* Space below message */
            text-align: center;                 /* Center the text */
        }

        /* SUCCESS MESSAGES
         * Green background for success notifications
         */
        .success-message {
            background: var(--accent-color);    /* Green background */
            color: white;                        /* White text for contrast */
            padding: var(--spacing-md);         /* Comfortable padding */
            border-radius: var(--radius-sm);    /* Rounded corners */
            margin-bottom: var(--spacing-md);   /* Space below message */
            text-align: center;                 /* Center the text */
        }

        /* ============================================
         * RESPONSIVE DESIGN
         * ============================================
         * Media queries adjust layout for different screen sizes
         */
        
        /* SMALL PHONE SCREENS (iPhone SE, older phones) */
        @media (max-width: 375px) {
            .container {
                padding: var(--spacing-sm);     /* Less padding on very small screens */
            }
            
            /* Stack stat cards vertically on small screens */
            .stats-container {
                grid-template-columns: 1fr;     /* Single column layout */
            }

            /* RESPONSIVE FORM LAYOUT
             * NEW: Stack description and amount vertically on very small screens
             * This ensures both fields remain usable even on tiny screens
             */
            .form-row {
                flex-direction: column;          /* Stack vertically instead of side-by-side */
            }

            .amount-input {
                width: 100%;                     /* Full width when stacked */
            }
        }

        /* ============================================
         * IOS-SPECIFIC OPTIMIZATIONS
         * ============================================
         */
        
        /* iOS WEBKIT SPECIFIC STYLES
         * Only apply these styles on iOS Safari
         */
        @supports (-webkit-touch-callout: none) {
            input, select {
                -webkit-appearance: none;        /* Remove iOS default styling */
                appearance: none;                /* Standard property for broader compatibility */
            }
        }

        /* ============================================
         * OFFLINE FUNCTIONALITY
         * ============================================
         */
        
        /* OFFLINE BANNER
         * Warning banner shown when user loses internet connection
         */
        .offline-banner {
            background: var(--warning-color);   /* Orange background for warning */
            color: white;                        /* White text */
            padding: var(--spacing-sm);         /* Compact padding */
            text-align: center;                 /* Center the message */
            font-size: 14px;                    /* Readable text size */
            display: none;                       /* Hidden by default */
        }

        /* Show offline banner when body has 'offline' class */
        body.offline .offline-banner {
            display: block;                      /* Make visible when offline */
        }
    </style>
</head>
<body>
    <!-- OFFLINE INDICATOR
         This banner appears when the user loses internet connection.
         JavaScript adds/removes the 'offline' class on the body element. -->
    <div class="offline-banner">
        You're offline - purchases will sync when connected
    </div>

    <!-- HEADER SECTION
         Sticky header that stays at the top when scrolling.
         Contains the app title in the brand color. -->
    <div class="header">
        <h1>Purchase Tracker</h1>
    </div>

    <!-- MAIN CONTAINER
         Centers all content and provides consistent spacing.
         Max-width prevents content from becoming too wide on large screens. -->
    <div class="container">
        <!-- MESSAGE CONTAINER
             JavaScript dynamically adds success/error messages here.
             Messages appear temporarily and auto-hide after 5 seconds. -->
        <div id="messageContainer"></div>

        <!-- STATISTICS SECTION
             Shows today's and this week's spending totals.
             Uses CSS Grid for responsive two-column layout. -->
        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-label">Today</div>
                <!-- JavaScript updates this value when purchases are added -->
                <div class="stat-value" id="todayTotal">$0.00</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">This Week</div>
                <!-- JavaScript calculates weekly total from all purchases -->
                <div class="stat-value" id="weekTotal">$0.00</div>
            </div>
        </div>

        <!-- PURCHASE FORM
             Main form for adding new purchases.
             JavaScript handles form submission and validation. -->
        <div class="purchase-form">
            <!-- The form element captures user input and triggers JavaScript when submitted -->
            <form id="purchaseForm">
                <!-- OPTIMIZED DESCRIPTION AND AMOUNT ROW
                     NEW: Description and amount fields now sit side by side to save vertical space
                     On small screens, they stack vertically for better usability -->
                <div class="form-row">
                    <!-- DESCRIPTION FIELD (takes remaining space) -->
                    <div style="flex: 1;">
                        <label for="description">Description</label>
                        <input 
                            type="text" 
                            id="description" 
                            name="description" 
                            placeholder="What did you buy?" 
                            required
                            autocomplete="off"
                        >
                    </div>
                    
                    <!-- AMOUNT FIELD (optimized smaller width) -->
                    <div>
                        <label for="amount">Amount</label>
                        <input 
                            type="number" 
                            id="amount" 
                            name="amount" 
                            class="amount-input"
                            placeholder="0.00" 
                            step="0.01" 
                            required
                            inputmode="decimal"
                        >
                    </div>
                </div>

                <!-- CATEGORY SELECTION BUTTONS
                     NEW: Replaces the dropdown select with interactive buttons
                     Provides faster selection and better mobile experience -->
                <div class="form-group">
                    <label>Category</label>
                    <div class="category-grid">
                        <button type="button" class="category-btn" data-category="Food & Dining">
                            Food & Dining
                        </button>
                        <button type="button" class="category-btn" data-category="Transportation">
                            Transportation
                        </button>
                        <button type="button" class="category-btn" data-category="Shopping">
                            Shopping
                        </button>
                        <button type="button" class="category-btn" data-category="Entertainment">
                            Entertainment
                        </button>
                        <button type="button" class="category-btn" data-category="Bills & Utilities">
                            Bills & Utilities
                        </button>
                        <button type="button" class="category-btn" data-category="Health & Medical">
                            Health & Medical
                        </button>
                        <button type="button" class="category-btn" data-category="Other">
                            Other
                        </button>
                    </div>
                    <!-- Hidden input to store selected category for form submission
                         This maintains compatibility with existing form processing code -->
                    <input type="hidden" id="category" name="category" required>
                </div>

                <!-- SUBMIT BUTTON
                     Triggers form submission and JavaScript processing -->
                <button type="submit" class="btn btn-primary">
                    Add Purchase
                </button>
            </form>
        </div>

        <!-- RECENT PURCHASES SECTION
             Displays the most recent purchases in a list format -->
        <div class="recent-purchases">
            <!-- SECTION HEADER
                 Contains title and sync controls in a flex layout -->
            <div class="section-header">
                <h2 class="section-title">Recent Purchases</h2>
                <!-- SYNC CONTROLS
                     Manual sync button and status indicator -->
                <div class="sync-controls">
                    <!-- Small sync button with refresh icon -->
                    <button class="sync-btn-small" id="syncButton" title="Sync now">
                        <!-- Refresh icon image (you'll need to add this file) -->
                        <img src="refresh-icon.png" alt="Refresh" class="refresh-icon-img">
                    </button>
                    <!-- Sync status with colored indicator dot -->
                    <div class="sync-status">
                        <span class="sync-indicator" id="syncIndicator"></span>
                        <span id="syncText">Synced</span>
                    </div>
                </div>
            </div>
            <!-- PURCHASES LIST
                 JavaScript populates this div with recent purchases -->
            <div id="purchasesList">
                <div class="empty-state">
                    No purchases yet. Add your first purchase above!
                </div>
            </div>
        </div>
    </div>

    <!-- JAVASCRIPT APPLICATION CODE
         All the interactive functionality is handled in JavaScript below -->
    <script>
        // ============================================
        // PURCHASE TRACKER APP - ENHANCED WITH DUPLICATE PREVENTION
        // ============================================
        
        /* CONFIGURATION OBJECT
         * This object contains all the important settings for the app.
         * By keeping them in one place, they're easy to find and modify.
         * Think of this like a settings file for the application.
         */
        const CONFIG = {
            // For caching purposes
            DEVELOPMENT_MODE: false,

            // ⚠️ IMPORTANT: Replace with your actual Google Apps Script URL
            // Get this from: Google Apps Script → Deploy → New deployment → Web app URL
            // This URL allows the app to send data to your Google Sheets
            GOOGLE_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbwwfGWbhkN77lGngf172nh-QLuhgA7ZSPczQ4u34x4m4dbe6Y-wyiBf-7gdV7CasyZd7g/exec',
            
            /* LOCAL STORAGE KEYS
             * localStorage is like a mini-database in the browser that persists between sessions.
             * These keys help organize different types of data we save locally.
             */
            STORAGE_KEYS: {
                PURCHASES: 'purchaseTracker_purchases',        // All purchase data
                PENDING_SYNC: 'purchaseTracker_pendingSync',   // Purchases waiting to sync to Google Sheets
                LAST_SYNC: 'purchaseTracker_lastSync',         // When we last successfully synced
                SETTINGS: 'purchaseTracker_settings'           // User preferences (for future features)
            },
            
            // UI SETTINGS
            RECENT_PURCHASES_LIMIT: 3,           // How many purchases to show in the recent list
            AUTO_SYNC_INTERVAL: 5 * 60 * 1000,  // Auto-sync every 5 minutes (milliseconds)
            
            /* DATE FORMATTING SETTINGS
             * Controls how dates and times appear in the interface
             * hour12: false gives us military time (24-hour format) like 14:30 instead of 2:30 PM
             */
            DATE_FORMAT: {
                dateStyle: 'short',   // Shows dates like "1/15/24"
                timeStyle: 'short',   // Shows times like "14:30" (military time)
                hour12: false         // Forces 24-hour format instead of AM/PM
            }
        };

        // ============================================
        // UTILITY FUNCTIONS
        // These are helper functions used throughout the app
        // ============================================
        
        /**
         * FORMAT CURRENCY FOR DISPLAY
         * Converts numbers to properly formatted currency strings
         * Example: 12.5 becomes "$12.50"
         * Uses the Intl.NumberFormat API for international number formatting
         * 
         * @param {number} amount - The amount to format (e.g., 12.5)
         * @returns {string} Formatted currency string (e.g., "$12.50")
         */
        function formatCurrency(amount) {
            return new Intl.NumberFormat('en-US', {
                style: 'currency',    // Format as currency
                currency: 'USD'       // Use US Dollar formatting
            }).format(amount);
        }

        /**
         * FORMAT DATE FOR DISPLAY
         * Converts ISO date strings to human-readable format with military time
         * Example: "2024-01-15T14:30:00.000Z" becomes "1/15/24, 14:30"
         * 
         * @param {string} dateString - ISO date string from JavaScript Date
         * @returns {string} Formatted date string for display
         */
        function formatDate(dateString) {
            return new Date(dateString).toLocaleString('en-US', CONFIG.DATE_FORMAT);
        }

        /**
         * CHECK IF TWO DATES ARE ON THE SAME DAY
         * Useful for calculating "today's" spending total
         * Compares year, month, and day (ignores time)
         * 
         * @param {Date} date1 - First date to compare
         * @param {Date} date2 - Second date to compare
         * @returns {boolean} True if both dates are on the same calendar day
         */
        function isSameDay(date1, date2) {
            return date1.getFullYear() === date2.getFullYear() &&
                   date1.getMonth() === date2.getMonth() &&
                   date1.getDate() === date2.getDate();
        }

        /**
         * CHECK IF TWO DATES ARE IN THE SAME WEEK
         * Useful for calculating "this week's" spending total
         * Week starts on Sunday (JavaScript's default getDay() behavior)
         * 
         * @param {Date} date1 - First date to compare
         * @param {Date} date2 - Second date to compare
         * @returns {boolean} True if both dates are in the same week
         */
        function isSameWeek(date1, date2) {
            // Get the start of the week (Sunday) for both dates
            const startOfWeek1 = new Date(date1);
            const startOfWeek2 = new Date(date2);
            
            // Set both dates to the beginning of their respective weeks
            // getDay() returns 0 for Sunday, 1 for Monday, etc.
            // Subtracting getDay() moves us back to the Sunday of that week
            startOfWeek1.setDate(date1.getDate() - date1.getDay());
            startOfWeek2.setDate(date2.getDate() - date2.getDay());
            
            // Set time to beginning of day for accurate comparison
            startOfWeek1.setHours(0, 0, 0, 0);
            startOfWeek2.setHours(0, 0, 0, 0);
            
            // Compare if both dates have the same week start date
            return startOfWeek1.getTime() === startOfWeek2.getTime();
        }

        /**
         * SHOW TEMPORARY MESSAGE TO USER
         * Displays success or error messages that automatically disappear
         * Messages appear at the top of the page and fade away after 5 seconds
         * 
         * @param {string} message - The message text to display
         * @param {string} type - 'success' or 'error' for different styling
         */
        function showMessage(message, type = 'success') {
            const messageContainer = document.getElementById('messageContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `${type}-message`;  // Apply success-message or error-message CSS class
            messageDiv.textContent = message;
            
            // Clear any existing messages first
            messageContainer.innerHTML = '';
            messageContainer.appendChild(messageDiv);
            
            // Automatically remove message after 5 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 5000);
        }

        // ============================================
        // LOCAL STORAGE MANAGEMENT
        // This handles saving and loading data from the browser's storage
        // ============================================
        
        /**
         * STORAGE MANAGER OBJECT
         * localStorage is like a mini-database that persists between browser sessions.
         * This object provides methods to safely save and retrieve our app data.
         * All data is stored as JSON strings and parsed back to JavaScript objects.
         */
        const Storage = {
            /**
             * GET ALL PURCHASES FROM LOCAL STORAGE
             * Retrieves the complete list of user's purchases
             * If no data exists, returns an empty array (first time user)
             * 
             * @returns {Array} Array of purchase objects
             */
            getPurchases() {
                const data = localStorage.getItem(CONFIG.STORAGE_KEYS.PURCHASES);
                return data ? JSON.parse(data) : [];  // Parse JSON or return empty array
            },

            /**
             * SAVE PURCHASES TO LOCAL STORAGE
             * Overwrites the entire purchases list with new data
             * Converts JavaScript objects to JSON string for storage
             * 
             * @param {Array} purchases - Array of purchase objects to save
             */
            savePurchases(purchases) {
                localStorage.setItem(CONFIG.STORAGE_KEYS.PURCHASES, JSON.stringify(purchases));
            },

            /**
             * ADD A SINGLE PURCHASE TO THE BEGINNING OF THE LIST
             * New purchases appear first in the UI (most recent first)
             * unshift() adds to the beginning, push() would add to the end
             * 
             * @param {Object} purchase - Purchase object to add
             * @returns {Object} The purchase that was added
             */
            addPurchase(purchase) {
                const purchases = this.getPurchases();
                purchases.unshift(purchase);  // Add to beginning of array
                this.savePurchases(purchases);
                return purchase;
            },

            /**
             * GET PURCHASES WAITING TO SYNC TO GOOGLE SHEETS
             * These are purchases made while offline or when sync failed
             * They'll be sent to Google Sheets the next time sync runs
             * 
             * @returns {Array} Array of unsynced purchases
             */
            getPendingSync() {
                const data = localStorage.getItem(CONFIG.STORAGE_KEYS.PENDING_SYNC);
                return data ? JSON.parse(data) : [];
            },

            /**
             * SAVE PURCHASES THAT NEED TO BE SYNCED
             * Maintains a queue of purchases waiting to go to Google Sheets
             * 
             * @param {Array} purchases - Array of purchases waiting to sync
             */
            savePendingSync(purchases) {
                localStorage.setItem(CONFIG.STORAGE_KEYS.PENDING_SYNC, JSON.stringify(purchases));
            },

            /**
             * CLEAR THE PENDING SYNC LIST
             * Called after successful sync to Google Sheets
             */
            clearPendingSync() {
                localStorage.setItem(CONFIG.STORAGE_KEYS.PENDING_SYNC, '[]');
            },

            /**
             * RECORD SUCCESSFUL SYNC TIMESTAMP
             * Keeps track of when we last successfully sent data to Google Sheets
             */
            updateLastSync() {
                localStorage.setItem(CONFIG.STORAGE_KEYS.LAST_SYNC, new Date().toISOString());
            },

            /**
             * GET LAST SUCCESSFUL SYNC TIME
             * Returns when we last successfully synced, or null if never synced
             * 
             * @returns {string|null} ISO date string or null
             */
            getLastSync() {
                return localStorage.getItem(CONFIG.STORAGE_KEYS.LAST_SYNC);
            }
        };

        // ============================================
        // CATEGORY BUTTON HANDLING
        // NEW SECTION: Manages the interactive category button selection
        // ============================================
        
        /**
         * HANDLE CATEGORY BUTTON SELECTION
         * This function manages which category button is selected and updates
         * the hidden form field that the existing form submission code expects
         */
        function handleCategorySelection() {
            // Get all category buttons using CSS selector
            const categoryButtons = document.querySelectorAll('.category-btn');
            
            // Add click event listener to each button
            categoryButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove 'selected' class from all buttons first
                    // This ensures only one button can be selected at a time
                    categoryButtons.forEach(btn => btn.classList.remove('selected'));
                    
                    // Add 'selected' class to the clicked button
                    // This triggers the CSS styling for selected state
                    this.classList.add('selected');
                    
                    // Update the hidden input field with the selected category
                    // The data-category attribute contains the category name
                    // This maintains compatibility with existing form processing
                    const hiddenCategoryInput = document.getElementById('category');
                    hiddenCategoryInput.value = this.getAttribute('data-category');
                    
                    // Remove any previous form validation errors since user made a selection
                    hiddenCategoryInput.setCustomValidity('');
                });
            });
        }

        /**
         * CLEAR CATEGORY SELECTION
         * NEW FUNCTION: Removes selection from all category buttons
         * Called after successful form submission to reset the form
         */
        function clearCategorySelection() {
            const categoryButtons = document.querySelectorAll('.category-btn');
            categoryButtons.forEach(btn => btn.classList.remove('selected'));
            
            // Clear the hidden input field as well
            document.getElementById('category').value = '';
        }

        // ============================================
        // UI UPDATE FUNCTIONS
        // These functions update what the user sees on screen
        // ============================================
        
        /**
         * UPDATE STATISTICS DISPLAY
         * Calculates and displays today's and this week's spending totals
         * Loops through all purchases and filters by date to calculate totals
         */
        function updateStats() {
            const purchases = Storage.getPurchases();
            const today = new Date();
            
            let todayTotal = 0;   // Running total for today's purchases
            let weekTotal = 0;    // Running total for this week's purchases
            
            // Loop through each purchase and add to appropriate totals
            purchases.forEach(purchase => {
                const purchaseDate = new Date(purchase.timestamp);
                const amount = parseFloat(purchase.amount);  // Ensure we have a number
                
                // Add to today's total if purchase was made today
                if (isSameDay(purchaseDate, today)) {
                    todayTotal += amount;
                }
                
                // Add to week's total if purchase was made this week
                if (isSameWeek(purchaseDate, today)) {
                    weekTotal += amount;
                }
            });
            
            // Update the numbers displayed on screen
            document.getElementById('todayTotal').textContent = formatCurrency(todayTotal);
            document.getElementById('weekTotal').textContent = formatCurrency(weekTotal);
        }

        /**
         * UPDATE RECENT PURCHASES LIST
         * Displays the most recent purchases in the UI
         * Limits the number shown to keep the interface manageable
         */
        function updatePurchasesList() {
            const purchases = Storage.getPurchases();
            const listContainer = document.getElementById('purchasesList');
            
            // If no purchases exist, show an encouraging message
            if (purchases.length === 0) {
                listContainer.innerHTML = `
                    <div class="empty-state">
                        No purchases yet. Add your first purchase above!
                    </div>
                `;
                return;
            }
            
            // Show only the most recent purchases (limited by config)
            const recentPurchases = purchases.slice(0, CONFIG.RECENT_PURCHASES_LIMIT);
            
            // Create HTML for each purchase using template literals
            // map() transforms each purchase object into an HTML string
            // join('') combines all HTML strings into one
            listContainer.innerHTML = recentPurchases.map(purchase => `
                <div class="purchase-item">
                    <div class="purchase-info">
                        <div class="purchase-description">${purchase.description}</div>
                        <div class="purchase-meta">
                            ${purchase.category} • ${formatDate(purchase.timestamp)}
                        </div>
                    </div>
                    <div class="purchase-amount">
                        ${formatCurrency(purchase.amount)}
                    </div>
                </div>
            `).join('');
        }

        /**
         * UPDATE SYNC STATUS INDICATOR
         * Shows users the current state of data synchronization
         * Uses colored dots and text to indicate sync status
         * 
         * @param {string} status - 'synced', 'pending', 'syncing', or 'error'
         * @param {string} text - Text to display next to the indicator
         */
        function updateSyncStatus(status, text) {
            const indicator = document.getElementById('syncIndicator');
            const syncText = document.getElementById('syncText');
            
            // Reset indicator classes (remove any existing status classes)
            indicator.className = 'sync-indicator';
            
            // Apply appropriate styling based on current status
            switch(status) {
                case 'pending':
                    indicator.classList.add('pending');  // Orange/yellow dot
                    break;
                case 'error':
                    indicator.classList.add('error');    // Red dot
                    break;
                case 'syncing':
                    // Show spinning animation during sync process
                    syncText.innerHTML = '<span class="loading"></span> Syncing...';
                    return;  // Exit early, don't update text below
            }
            
            // Update the status text (for non-syncing states)
            syncText.innerHTML = text.replace(' ', '<br>');  // Replace first space with line break
        }

        // ============================================
        // ENHANCED SYNC STATE MANAGEMENT (NEW)
        // ============================================
        
        /**
         * NEW: GLOBAL SYNC STATE TRACKER
         * 
         * This flag prevents multiple sync operations from running simultaneously.
         * This is crucial for preventing duplicate data submission:
         * 
         * PROBLEM WITHOUT THIS FLAG:
         * 1. User adds a purchase (triggers auto-sync after 2 seconds)
         * 2. User clicks sync button manually (triggers immediate sync)
         * 3. Both syncs run at the same time
         * 4. Both send the same data to Google Sheets
         * 5. Result: Duplicates in your spreadsheet
         * 
         * SOLUTION WITH THIS FLAG:
         * 1. Before starting any sync, check if isSyncing is true
         * 2. If true, skip the sync attempt
         * 3. If false, set isSyncing = true and proceed
         * 4. Always set isSyncing = false when sync completes (success or failure)
         * 
         * This is called "mutual exclusion" or "mutex" in computer science
         */
        let isSyncing = false;
        
        /**
         * NEW: ENHANCED SYNC ATTEMPT TRACKING
         * 
         * These variables help us understand sync patterns and provide better
         * user feedback about what's happening with their data.
         */
        let lastSyncAttempt = null;  // When we last tried to sync
        let consecutiveFailures = 0; // How many syncs have failed in a row

        // ============================================
        // ENHANCED SYNC FUNCTIONALITY (COMPLETELY REWRITTEN)
        // ============================================
        
        /**
         * ENHANCED MAIN SYNC FUNCTION
         * 
         * This replaces your original syncPurchases() function with significant improvements:
         * 
         * KEY IMPROVEMENTS:
         * 1. COLLISION PREVENTION: Prevents multiple simultaneous syncs
         * 2. BETTER TIMING: Smarter delays and retry logic
         * 3. ENHANCED ERROR HANDLING: More specific error messages
         * 4. DETAILED LOGGING: Better debugging information
         * 5. USER FEEDBACK: Clear status updates throughout the process
         * 
         * HOW COLLISION PREVENTION WORKS:
         * - Check isSyncing flag before starting
         * - Set flag to true when starting sync
         * - Always clear flag when done (using finally block)
         * - Provide user feedback when sync is already running
         * 
         * WHY THIS PREVENTS DUPLICATES:
         * - Only one sync can run at a time
         * - Each sync sends a complete batch of pending purchases
         * - Google Apps Script now checks for duplicates server-side
         * - Result: No duplicate entries in your spreadsheet
         * 
         * @returns {Promise<void>} Promise that resolves when sync completes
         */
        async function syncPurchases() {
            // ============================================
            // STEP 1: COLLISION PREVENTION
            // ============================================
            
            // Check if a sync is already running
            if (isSyncing) {
                console.log('🔄 Sync collision prevented: Another sync is already in progress');
                console.log('⏱️ This prevents duplicate data from being sent to Google Sheets');
                
                // Update UI to show user that sync is already happening
                showMessage('Sync already in progress...', 'error');
                return; // Exit early - don't start another sync
            }
            
            // ============================================
            // STEP 2: BASIC VALIDATION
            // ============================================
            
            // Verify that Google Apps Script URL is configured
            if (!CONFIG.GOOGLE_SCRIPT_URL.startsWith('https://script.google.com/')) {
                console.warn('❌ Google Apps Script URL not configured properly');
                updateSyncStatus('error', 'Sync not configured');
                showMessage('Sync not configured. Please check your Google Apps Script URL.', 'error');
                return;
            }
            
            // Get purchases that need to be synced
            const pending = Storage.getPendingSync();
            
            // If nothing to sync, we're already up to date
            if (pending.length === 0) {
                console.log('✅ No pending purchases to sync');
                updateSyncStatus('synced', 'Synced');
                return;
            }
            
            // ============================================
            // STEP 3: START SYNC PROCESS
            // ============================================
            
            // Set the collision prevention flag
            isSyncing = true;
            lastSyncAttempt = new Date();
            
            // Show user that sync is starting
            console.log(`🚀 Starting sync process with ${pending.length} pending purchase(s)`);
            updateSyncStatus('syncing', 'Syncing...');
            
            // Log details about what we're syncing (for debugging)
            pending.forEach((purchase, index) => {
                console.log(`   ${index + 1}. ${purchase.description} - ${purchase.amount} (ID: ${purchase.id})`);
            });
            
            try {
                // ============================================
                // STEP 4: ATTEMPT SYNC WITH ENHANCED ERROR HANDLING
                // ============================================
                
                // Prepare data in the format expected by Google Apps Script
                const requestData = {
                    action: 'addPurchases',  // This tells Google Apps Script what to do
                    purchases: pending       // The actual purchase data to save
                };
                
                console.log('📤 Sending data to Google Apps Script...');
                
                // Try the main sync method first
                const syncSuccess = await attemptMainSync(requestData);
                
                if (syncSuccess) {
                    // ============================================
                    // STEP 5A: HANDLE SUCCESSFUL SYNC
                    // ============================================
                    
                    console.log('✅ Main sync method succeeded');
                    await handleSyncSuccess(pending);
                    consecutiveFailures = 0; // Reset failure counter
                    
                } else {
                    // ============================================
                    // STEP 5B: HANDLE FAILED SYNC WITH FALLBACK
                    // ============================================
                    
                    console.log('⚠️ Main sync failed, attempting fallback method...');
                    consecutiveFailures++;
                    
                    // Try the form submission fallback method
                    await syncWithFormSubmissionFallback(pending);
                }
                
            } catch (error) {
                // ============================================
                // STEP 6: HANDLE CRITICAL ERRORS
                // ============================================
                
                console.error('❌ Critical sync error occurred:', error);
                console.error('📍 Error details:', {
                    message: error.message,
                    stack: error.stack,
                    timestamp: new Date().toISOString(),
                    pendingCount: pending.length
                });
                
                consecutiveFailures++;
                
                // Update UI with error information
                updateSyncStatus('error', 'Sync failed');
                
                // Provide helpful error messages based on the type of error
                if (error.name === 'NetworkError' || error.message.includes('fetch')) {
                    showMessage('Network error. Check your internet connection.', 'error');
                } else if (error.message.includes('CORS')) {
                    showMessage('CORS error. This is normal - data may still have been saved.', 'error');
                } else {
                    showMessage(`Sync failed: ${error.message}. Will retry when online.`, 'error');
                }
                
                // Log guidance for debugging
                console.log('🔧 Debugging suggestions:');
                console.log('   1. Check your internet connection');
                console.log('   2. Verify your Google Apps Script URL is correct');
                console.log('   3. Check the Google Apps Script logs for server-side errors');
                console.log('   4. Try the manual sync button');
                
            } finally {
                // ============================================
                // STEP 7: CLEANUP (ALWAYS RUNS)
                // ============================================
                
                // CRITICAL: Always clear the sync flag, even if errors occurred
                // This ensures the app doesn't get stuck in a "syncing" state
                isSyncing = false;
                
                console.log('🏁 Sync process completed, collision flag cleared');
                
                // Log sync statistics for monitoring
                console.log('📊 Sync Statistics:', {
                    lastAttempt: lastSyncAttempt,
                    consecutiveFailures: consecutiveFailures,
                    pendingCount: Storage.getPendingSync().length
                });
            }
        }

        /**
         * NEW: ENHANCED MAIN SYNC ATTEMPT
         * 
         * This function handles the primary sync method using fetch().
         * It's separated from the main function for better error handling
         * and to make testing easier.
         * 
         * KEY LEARNING CONCEPTS:
         * 1. SEPARATION OF CONCERNS: Each function has one clear responsibility
         * 2. ERROR ISOLATION: Errors in sync attempts don't crash the main function
         * 3. RETURN VALUES: Boolean return indicates success/failure clearly
         * 4. ASYNC/AWAIT: Modern JavaScript for handling asynchronous operations
         * 
         * WHY 'NO-CORS' MODE:
         * Google Apps Script has CORS restrictions that prevent normal browser requests.
         * 'no-cors' mode allows us to send data but not read the response.
         * This is a limitation of browser security, but the data still gets processed.
         * 
         * @param {Object} requestData - The data to send to Google Apps Script
         * @returns {Promise<boolean>} True if the request was sent successfully
         */
        async function attemptMainSync(requestData) {
            console.log('🌐 Attempting primary sync method via fetch()...');
            
            try {
                // Send the POST request to Google Apps Script
                const response = await fetch(CONFIG.GOOGLE_SCRIPT_URL, {
                    method: 'POST',                    // Use POST to send data
                    mode: 'no-cors',                   // Required for Google Apps Script (security limitation)
                    headers: {
                        'Content-Type': 'application/json',  // Tell server we're sending JSON
                    },
                    body: JSON.stringify(requestData)  // Convert JavaScript object to JSON string
                });
                
                // WITH 'NO-CORS' MODE:
                // - We can send the request successfully
                // - We cannot read the response (browser security restriction)
                // - If fetch() doesn't throw an error, we assume it worked
                // - This is a limitation we have to work with for Google Apps Script
                
                console.log('📤 Request sent successfully to Google Apps Script');
                console.log('ℹ️ Note: Cannot read response due to CORS restrictions, but data should be processed');
                
                return true; // Assume success if no error was thrown
                
            } catch (error) {
                // Log the specific error for debugging
                console.error('❌ Primary sync method failed:', error.message);
                
                // Common error types and what they mean:
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    console.log('🔍 This is likely a network connectivity issue');
                } else if (error.message.includes('CORS')) {
                    console.log('🔍 CORS error - this might actually be normal with Google Apps Script');
                } else {
                    console.log('🔍 Unexpected error type:', error.name);
                }
                
                return false; // Indicate that this method failed
            }
        }

        /**
         * NEW: ENHANCED SYNC SUCCESS HANDLER
         * 
         * This function handles all the tasks that need to happen when a sync
         * operation succeeds. By centralizing this logic, we ensure consistency
         * between different sync methods.
         * 
         * TASKS PERFORMED:
         * 1. Mark synced purchases as synced in local storage
         * 2. Clear the pending sync queue
         * 3. Record the successful sync timestamp
         * 4. Update the user interface
         * 5. Show success message to user
         * 6. Log detailed success information
         * 
         * WHY CENTRALIZE THIS:
         * - Both primary and fallback sync methods need the same cleanup
         * - Reduces code duplication
         * - Ensures consistent behavior
         * - Makes testing easier
         * 
         * @param {Array} syncedPurchases - Array of purchases that were successfully synced
         */
        async function handleSyncSuccess(syncedPurchases) {
            console.log('✅ Processing successful sync...');
            
            try {
                // ============================================
                // UPDATE LOCAL STORAGE
                // ============================================
                
                // Mark all synced purchases as synced in local storage
                // This prevents them from being sent again in future syncs
                const allPurchases = Storage.getPurchases();
                let updatedCount = 0;
                
                allPurchases.forEach(purchase => {
                    // Find purchases that were just synced and mark them
                    if (syncedPurchases.find(p => p.id === purchase.id)) {
                        purchase.synced = true;
                        updatedCount++;
                    }
                });
                
                // Save the updated purchase list back to local storage
                Storage.savePurchases(allPurchases);
                
                console.log(`📝 Marked ${updatedCount} purchases as synced in local storage`);
                
                // ============================================
                // CLEAR PENDING QUEUE
                // ============================================
                
                // Clear the pending sync queue since everything was successful
                Storage.clearPendingSync();
                console.log('🗑️ Cleared pending sync queue');
                
                // Record the successful sync timestamp for future reference
                Storage.updateLastSync();
                console.log('⏰ Updated last sync timestamp');
                
                // ============================================
                // UPDATE USER INTERFACE
                // ============================================
                
                // Update sync status indicator to show success
                updateSyncStatus('synced', 'Synced');
                
                // Show success message to user
                showMessage(`Successfully synced ${syncedPurchases.length} purchase(s) to Google Sheets!`, 'success');
                
                // ============================================
                // SUCCESS LOGGING
                // ============================================
                
                console.log('🎉 Sync success details:', {
                    purchasesSynced: syncedPurchases.length,
                    timestamp: new Date().toISOString(),
                    method: 'primary', // Could be enhanced to track which method was used
                    consecutiveFailures: consecutiveFailures
                });
                
                // If we had previous failures, mention the recovery
                if (consecutiveFailures > 0) {
                    console.log(`🔄 Recovered from ${consecutiveFailures} consecutive failure(s)`);
                }
                
            } catch (error) {
                console.error('❌ Error during sync success handling:', error);
                // Don't throw the error - the sync itself was successful
                // This is just cleanup, so we log the error but don't fail the entire operation
            }
        }

        /**
         * NEW: ENHANCED FORM SUBMISSION FALLBACK
         * 
         * This function provides a backup sync method when the primary fetch() method fails.
         * It uses HTML form submission to bypass some CORS restrictions.
         * 
         * HOW IT WORKS:
         * 1. Creates an invisible HTML form dynamically
         * 2. Adds the purchase data as a hidden form field
         * 3. Submits the form to your Google Apps Script URL
         * 4. Opens result in a new tab (prevents page navigation)
         * 5. Cleans up the temporary form
         * 6. Assumes success after a reasonable delay
         * 
         * WHY THIS WORKS:
         * - Form submissions have different CORS rules than fetch()
         * - Google Apps Script can handle both JSON and form data
         * - This method often works when fetch() fails
         * 
         * LIMITATIONS:
         * - Can't read the response (opens in new tab)
         * - Must assume success based on timing
         * - Less reliable than primary method
         * 
         * @param {Array} purchases - Array of purchases to sync
         * @returns {Promise<void>} Promise that resolves when fallback completes
         */
        async function syncWithFormSubmissionFallback(purchases) {
            console.log('📋 Using form submission fallback method...');
            console.log('ℹ️ This method works around CORS restrictions by using HTML form submission');
            
            return new Promise((resolve) => {
                try {
                    // ============================================
                    // CREATE DYNAMIC FORM
                    // ============================================
                    
                    // Create a form element in memory (not visible to user)
                    const form = document.createElement('form');
                    form.method = 'POST';                    // Use POST method to send data
                    form.action = CONFIG.GOOGLE_SCRIPT_URL;  // Send to your Google Apps Script
                    form.target = '_blank';                  // Open result in new tab (prevents page navigation)
                    form.style.display = 'none';            // Make form completely invisible
                    
                    // Create a hidden input field to hold our purchase data
                    const input = document.createElement('input');
                    input.type = 'hidden';                   // Hidden from user
                    input.name = 'data';                     // Field name that Google Apps Script expects
                    input.value = JSON.stringify({          // Convert data to JSON string
                        action: 'addPurchases',
                        purchases: purchases
                    });
                    
                    // ============================================
                    // SUBMIT FORM
                    // ============================================
                    
                    // Assemble the form by adding the input field
                    form.appendChild(input);
                    
                    // Add form to the page (required for submission)
                    document.body.appendChild(form);
                    
                    console.log('📤 Submitting form with purchase data...');
                    
                    // Submit the form - this sends the data to Google Apps Script
                    form.submit();
                    
                    console.log('✅ Form submitted successfully');
                    
                    // ============================================
                    // CLEANUP AND SUCCESS HANDLING
                    // ============================================
                    
                    // Remove the temporary form after a short delay
                    setTimeout(() => {
                        try {
                            if (document.body.contains(form)) {
                                document.body.removeChild(form);
                                console.log('🗑️ Cleaned up temporary form');
                            }
                        } catch (cleanupError) {
                            console.warn('⚠️ Form cleanup error (not critical):', cleanupError.message);
                        }
                    }, 1000);
                    
                    // Wait for a reasonable amount of time, then assume success
                    // We use a longer delay than the original to be more confident
                    setTimeout(async () => {
                        console.log('⏳ Fallback method timeout reached, assuming success...');
                        
                        try {
                            // Handle the sync as successful
                            await handleSyncSuccess(purchases);
                            
                            // Special message for fallback method
                            showMessage('Sync completed via fallback method. Check your Google Sheet to verify.', 'success');
                            
                            console.log('✅ Fallback method completed');
                            
                        } catch (error) {
                            console.error('❌ Error in fallback success handling:', error);
                            updateSyncStatus('error', 'Sync uncertain');
                            showMessage('Fallback method completed, but status uncertain. Check your Google Sheet.', 'error');
                        }
                        
                        resolve(); // Resolve the Promise to indicate completion
                        
                    }, 5000); // Increased delay to 5 seconds for better reliability
                    
                } catch (error) {
                    console.error('❌ Form submission fallback failed:', error);
                    updateSyncStatus('error', 'All methods failed');
                    showMessage('All sync methods failed. Will retry when online.', 'error');
                    resolve(); // Still resolve to prevent hanging
                }
            });
        }

        // ============================================
        // ENHANCED FORM HANDLING (UPDATED)
        // ============================================
        
        /**
         * ENHANCED PURCHASE FORM SUBMISSION HANDLER
         * 
         * This function runs when the user clicks "Add Purchase"
         * It processes the form data and saves the purchase
         * 
         * ENHANCED FEATURES:
         * 1. Better auto-sync timing to prevent sync storms
         * 2. Collision prevention for sync operations
         * 3. More detailed logging for debugging
         * 4. Enhanced error handling and user feedback
         */
        document.getElementById('purchaseForm').addEventListener('submit', async (e) => {
            e.preventDefault(); // Prevent the browser's default form submission behavior
            
            console.log('📝 Purchase form submitted');
            
            // ============================================
            // FORM VALIDATION (ENHANCED)
            // ============================================
            
            // CATEGORY VALIDATION
            // Check if user selected a category before processing form
            const selectedCategory = document.getElementById('category').value;
            if (!selectedCategory) {
                console.log('❌ Form validation failed: No category selected');
                showMessage('Please select a category', 'error');
                return; // Stop form submission if no category selected
            }
            
            // ============================================
            // CREATE PURCHASE OBJECT
            // ============================================
            
            // Extract data from the form using FormData API
            const formData = new FormData(e.target);
            
            // Create a purchase object with all the necessary data
            const purchase = {
                id: Date.now().toString(),           // Simple unique ID using current timestamp
                description: formData.get('description'),  // What the user bought
                amount: parseFloat(formData.get('amount')), // Cost (converted to number)
                category: selectedCategory,                 // Selected category from button
                timestamp: new Date().toISOString(),       // Current time in ISO format
                synced: false                               // Mark as not yet synced to Google Sheets
            };
            
            console.log('💰 New purchase created:', {
                id: purchase.id,
                description: purchase.description,
                amount: purchase.amount,
                category: purchase.category
            });
            
            // ============================================
            // SAVE LOCALLY AND UPDATE UI
            // ============================================
            
            // Save the purchase locally first (enables offline functionality)
            Storage.addPurchase(purchase);
            
            // Add to the queue of purchases that need to be synced
            const pending = Storage.getPendingSync();
            pending.push(purchase);
            Storage.savePendingSync(pending);
            
            // Update the user interface immediately
            updateStats();          // Recalculate today/week totals
            updatePurchasesList();  // Add to recent purchases list
            updateSyncStatus('pending', 'Pending');  // Show pending status
            
            // ============================================
            // RESET FORM FOR NEXT ENTRY
            // ============================================
            
            // Reset the form for the next purchase entry
            e.target.reset();
            clearCategorySelection();  // Clear category button selection
            
            // Put cursor back in description field for quick consecutive entries
            document.getElementById('description').focus();
            
            // Show success feedback to the user
            showMessage('Purchase added successfully!', 'success');
            
            // ============================================
            // ENHANCED AUTO-SYNC LOGIC
            // ============================================
            
            // Only attempt auto-sync if online and not already syncing
            if (navigator.onLine && !isSyncing) {
                console.log('⏰ Scheduling auto-sync after purchase...');
                
                // Use a longer delay to allow for multiple quick entries
                // This prevents sync storms when users add multiple purchases rapidly
                setTimeout(() => {
                    // Double-check that sync isn't running (could have started manually)
                    if (!isSyncing) {
                        console.log('🤖 Starting auto-sync after purchase...');
                        syncPurchases();
                    } else {
                        console.log('⚠️ Auto-sync skipped: manual sync already running');
                    }
                }, 3000); // Increased delay to 3 seconds
                
            } else if (!navigator.onLine) {
                console.log('📱 Auto-sync skipped: device is offline');
            } else {
                console.log('🔄 Auto-sync skipped: sync already in progress');
            }
        });

        // ============================================
        // ENHANCED EVENT LISTENERS (UPDATED)
        // ============================================

        /**
         * ENHANCED MANUAL SYNC BUTTON HANDLER
         * 
         * This replaces your original sync button event listener with better
         * collision prevention and user feedback.
         */
        document.getElementById('syncButton').addEventListener('click', () => {
            console.log('🖱️ Manual sync button clicked');
            
            // Check if sync is already running
            if (isSyncing) {
                console.log('⚠️ Manual sync blocked: sync already in progress');
                showMessage('Sync already in progress. Please wait...', 'error');
                return;
            }
            
            // Check if we're online
            if (!navigator.onLine) {
                console.log('⚠️ Manual sync blocked: device is offline');
                showMessage('Cannot sync while offline. Check your internet connection.', 'error');
                return;
            }
            
            // Start manual sync
            console.log('🚀 Starting manual sync...');
            showMessage('Manual sync started...', 'success');
            syncPurchases();
        });

        /**
         * ENHANCED ONLINE EVENT HANDLER
         * 
         * This improves the existing online event handler with better
         * collision prevention and user feedback.
         */
        window.addEventListener('online', () => {
            console.log('🌐 Device came back online');
            
            // Remove offline indicator
            document.body.classList.remove('offline');
            
            // Check if we have pending purchases to sync
            const pendingCount = Storage.getPendingSync().length;
            
            if (pendingCount > 0) {
                console.log(`📤 Found ${pendingCount} pending purchases, attempting sync...`);
                showMessage(`Back online! Syncing ${pendingCount} pending purchase(s)...`, 'success');
                
                // Small delay to ensure connection is stable
                setTimeout(() => {
                    if (!isSyncing) {
                        syncPurchases();
                    } else {
                        console.log('⚠️ Online sync skipped: sync already in progress');
                    }
                }, 1000);
                
            } else {
                console.log('✅ No pending purchases to sync');
                showMessage('Back online! All purchases are already synced.', 'success');
                updateSyncStatus('synced', 'Synced');
            }
        });

        /**
         * ENHANCED OFFLINE EVENT HANDLER
         * 
         * Provides better user feedback when going offline.
         */
        window.addEventListener('offline', () => {
            console.log('📱 Device went offline');
            
            // Show offline indicator
            document.body.classList.add('offline');
            
            // If sync was running, it will fail gracefully
            if (isSyncing) {
                console.log('⚠️ Sync was running when offline - will handle gracefully');
            }
            
            // Update sync status and show message
            const pendingCount = Storage.getPendingSync().length;
            if (pendingCount > 0) {
                updateSyncStatus('pending', `${pendingCount} pending`);
                showMessage(`You're offline. ${pendingCount} purchase(s) will sync when reconnected.`, 'error');
            } else {
                showMessage('You\'re offline. New purchases will sync when reconnected.', 'error');
            }
        });

        // ============================================
        // EXPORT FUNCTIONALITY (UNCHANGED)
        // ============================================
        
        /**
         * EXPORT PURCHASES AS CSV FILE
         * Creates a downloadable spreadsheet file with all purchase data
         * CSV (Comma Separated Values) can be opened in Excel, Google Sheets, etc.
         * 
         * This function remains exactly the same as before
         */
        function exportPurchases() {
            const purchases = Storage.getPurchases();
            
            // Check if there's any data to export
            if (purchases.length === 0) {
                showMessage('No purchases to export', 'error');
                return;
            }
            
            // Define CSV column headers
            const headers = ['Date', 'Time', 'Description', 'Amount', 'Category'];
            
            // Convert each purchase to a row of CSV data
            const rows = purchases.map(purchase => {
                const date = new Date(purchase.timestamp);
                return [
                    date.toLocaleDateString(),                    // Date in local format
                    date.toLocaleTimeString('en-US', { hour12: false }), // Military time format
                    purchase.description,                         // What was bought
                    purchase.amount,                             // Cost
                    purchase.category                            // Category
                ];
            });
            
            // Combine headers and data into CSV format
            // Each cell is wrapped in quotes to handle commas in descriptions
            const csvContent = [
                headers.join(','),  // Header row
                ...rows.map(row => row.map(cell => `"${cell}"`).join(','))  // Data rows
            ].join('\n');  // Join rows with newlines
            
            // Create a downloadable file and trigger download
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `purchases_${new Date().toISOString().split('T')[0]}.csv`;  // Filename with date
            a.click();  // Trigger download
            
            // Clean up the temporary URL
            URL.revokeObjectURL(url);
            
            showMessage('Export downloaded!', 'success');
        }

        // ============================================
        // ENHANCED AUTOMATIC SYNC INTERVAL (UPDATED)
        // ============================================

        /**
         * ENHANCED AUTOMATIC SYNC TIMER
         * 
         * This improves the existing auto-sync interval with better
         * collision prevention and adaptive timing.
         */
        setInterval(() => {
            // Only attempt automatic sync if:
            // 1. We're online
            // 2. No sync is currently running
            // 3. We have pending purchases
            if (navigator.onLine && !isSyncing) {
                const pendingCount = Storage.getPendingSync().length;
                
                if (pendingCount > 0) {
                    console.log(`🕐 Automatic sync triggered (${pendingCount} pending purchases)`);
                    syncPurchases();
                }
                // If no pending purchases, we don't log anything to avoid console spam
            }
            
        }, CONFIG.AUTO_SYNC_INTERVAL); // Uses your existing 5-minute interval

        // ============================================
        // SERVICE WORKER REGISTRATION (UNCHANGED)
        // ============================================
        
        /* SERVICE WORKER SETUP
         * Service workers cache your app files so it works without internet connection.
         * This is an advanced feature that requires additional setup.
         */
        
        if ('serviceWorker' in navigator && !CONFIG.DEVELOPMENT_MODE) {
            // PRODUCTION MODE: Register service worker for full PWA functionality
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => {
                        console.log('🚀 Service Worker registered successfully (Production Mode)');
                        
                        // Check for updates every minute in production
                        setInterval(() => {
                            reg.update();
                            console.log('🔄 Checking for app updates...');
                        }, 60000);
                        
                        // Listen for service worker updates
                        reg.addEventListener('updatefound', () => {
                            console.log('📦 New app version found, installing...');
                            const newWorker = reg.installing;
                            
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('✅ New app version ready! Refresh to update.');
                                    showMessage('New app version available! Refresh to update.', 'success');
                                }
                            });
                        });
                    })
                    .catch(err => console.error('❌ Service Worker registration failed:', err));
            });
            
        } else if (CONFIG.DEVELOPMENT_MODE) {
            // DEVELOPMENT MODE: Service worker disabled for easier development
            console.log('🚧 DEVELOPMENT MODE: Service Worker disabled for easier testing');
            console.log('💡 This means:');
            console.log('   - No caching (always fresh content)');
            console.log('   - No offline functionality');
            console.log('   - Easier debugging and updates');
            console.log('   - Set CONFIG.DEVELOPMENT_MODE = false for production');
            
            // Add helpful development tools to the global scope
            window.devHelpers = {
                // Clear all local storage data
                clearStorage: () => {
                    localStorage.clear();
                    console.log('🗑️ Local storage cleared');
                    updateStats();
                    updatePurchasesList();
                    showMessage('Local storage cleared!', 'success');
                },
                
                // Export all current data for debugging
                exportData: () => {
                    const data = {
                        purchases: Storage.getPurchases(),
                        pending: Storage.getPendingSync(),
                        lastSync: Storage.getLastSync(),
                        timestamp: new Date().toISOString()
                    };
                    console.log('📊 Current app data:', data);
                    return data;
                },
                
                // Force a sync attempt (bypassing collision prevention)
                forceSync: () => {
                    console.log('🔧 DEV: Forcing sync (bypassing collision prevention)');
                    const wassyncing = isSyncing;
                    isSyncing = false; // Temporarily clear flag
                    syncPurchases().finally(() => {
                        if (wassyncing) {
                            console.log('🔧 DEV: Restored previous sync state');
                        }
                    });
                },
                
                // Check current sync state
                getSyncState: () => {
                    const state = {
                        isSyncing: isSyncing,
                        lastSyncAttempt: lastSyncAttempt,
                        consecutiveFailures: consecutiveFailures,
                        pendingCount: Storage.getPendingSync().length,
                        lastSuccessfulSync: Storage.getLastSync()
                    };
                    console.log('🔧 DEV: Current sync state:', state);
                    return state;
                },
                
                // Simulate sync collision for testing
                simulateSyncCollision: () => {
                    console.log('🔧 DEV: Simulating sync collision...');
                    isSyncing = true;
                    setTimeout(() => {
                        console.log('🔧 DEV: Attempting sync during collision...');
                        syncPurchases();
                    }, 1000);
                    setTimeout(() => {
                        console.log('🔧 DEV: Clearing collision flag');
                        isSyncing = false;
                    }, 5000);
                },
                
                // Simulate offline mode for testing
                simulateOffline: () => {
                    document.body.classList.add('offline');
                    showMessage('Simulating offline mode', 'error');
                    console.log('📱 Offline mode simulated. Call devHelpers.simulateOnline() to restore.');
                },
                
                // Restore online mode
                simulateOnline: () => {
                    document.body.classList.remove('offline');
                    showMessage('Online mode restored', 'success');
                    console.log('🌐 Online mode restored');
                },
                
                // Show current configuration
                showConfig: () => {
                    console.log('⚙️ Current configuration:', CONFIG);
                    return CONFIG;
                },
                
                // Reset sync state for testing
                resetSyncState: () => {
                    console.log('🔧 DEV: Resetting sync state');
                    isSyncing = false;
                    lastSyncAttempt = null;
                    consecutiveFailures = 0;
                    updateSyncStatus('synced', 'Reset');
                }
            };
            
            // Log available development helpers
            console.log('🛠️ Enhanced development helpers available:');
            console.log('   devHelpers.clearStorage()        - Clear all data');
            console.log('   devHelpers.exportData()          - Export current data');
            console.log('   devHelpers.forceSync()           - Force sync (bypass collision prevention)');
            console.log('   devHelpers.getSyncState()        - Check current sync state');
            console.log('   devHelpers.simulateSyncCollision() - Test collision prevention');
            console.log('   devHelpers.simulateOffline()     - Test offline mode');
            console.log('   devHelpers.simulateOnline()      - Restore online mode');
            console.log('   devHelpers.showConfig()          - Show configuration');
            console.log('   devHelpers.resetSyncState()      - Reset sync state for testing');
            
        } else {
            // Fallback: Service worker not supported in this browser
            console.log('⚠️ Service Worker not supported in this browser');
        }
        
        // ============================================
        // APPLICATION INITIALIZATION (ENHANCED)
        // ============================================
        
        /**
         * ENHANCED INITIALIZE THE APPLICATION
         * Sets up the initial state and starts background processes
         * This is the main entry point that gets everything running
         * 
         * ENHANCED FEATURES:
         * 1. Better logging for initialization process
         * 2. Enhanced sync state detection
         * 3. Improved initial UI setup
         */
        function init() {
            console.log('🚀 Initializing Enhanced Purchase Tracker application...');
            console.log('📋 Features: Duplicate prevention, collision detection, enhanced sync');
            
            // Set up category button event handlers
            // This must be called before the form becomes interactive
            handleCategorySelection();
            console.log('✅ Category button handlers initialized');
            
            // Load and display existing data from localStorage
            updateStats();          // Calculate and show today/week totals
            updatePurchasesList();  // Display recent purchases
            console.log('✅ UI updated with existing data');
            
            // Check initial online/offline state
            if (!navigator.onLine) {
                document.body.classList.add('offline');
                console.log('📱 Device is currently offline');
            } else {
                console.log('🌐 Device is online');
            }
            
            // Check if we have purchases waiting to sync and update status accordingly
            const pending = Storage.getPendingSync();
            if (pending.length > 0) {
                updateSyncStatus('pending', 'Pending');
                console.log(`📤 Found ${pending.length} purchases waiting to sync`);
            } else {
                updateSyncStatus('synced', 'Synced');
                console.log('✅ No pending purchases to sync');
            }
            
            // Focus on description field for immediate data entry
            // This improves user experience by letting them start typing right away
            document.getElementById('description').focus();
            
            // Log initialization completion
            console.log('✅ Enhanced Purchase Tracker initialized successfully');
            console.log('🔒 Duplicate prevention: ACTIVE');
            console.log('🚦 Sync collision prevention: ACTIVE');
            console.log('🔄 Auto-sync interval: 5 minutes');
            
            // Show initialization message to user
            showMessage('Purchase Tracker loaded with enhanced duplicate prevention!', 'success');
        }
        
        // ============================================
        // START THE APPLICATION
        // ============================================
        
        // This line kicks off the entire enhanced app when the page loads
        init();
    </script>
</body>
</html>